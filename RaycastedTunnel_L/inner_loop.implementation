void rayCalc(vec3 *r, float *r_depth, uint32 *u, uint32 *v) {
	float vec_len = sqrt(r->x * r->x + r->y * r->y);
	if (vec_len != 0.0f) {
	  float t = cylinder_radius / vec_len;
	
	  float angle = atan2(r->x, r->y);
	  
	  *r_depth = r->z * t;

	  int _u = *r_depth;
	  int _v = (angle * 511) / (PI * 2.0f);

	  *u = abs(_u);

	  if (_v < 0) {
		*v = 511 - abs(_v);
	  } else {
		*v = _v;
	  }
	  
	  *u &= 511;
	  *v &= 511;
	}
}

for (int y = 0; y < height; y += 8) {
	float alpha = (float)y / (float)height;
      
    vec3 left = lerp(&top_left_, &bottom_left_, alpha);
    vec3 right = lerp(&top_right_, &bottom_right_, alpha);
      
	float delta_x = (right.x - left.x) / (float)width;
    float delta_y = (right.y - left.y) / (float)width;
    float delta_z = (right.z - left.z) / (float)width;
	  
    vec3 ray;
    copyVec3(&ray, &left);
	
	for (int x = 0; x < width; x += 8) {
		vec3 ray_tr; ray_tr.x = ray.x + 8 * delta_x; ray_tr.y = ray.y;
		vec3 ray_tl = ray,
		vec3 ray_br; ray_br.x = ray.x + 8 * delta_x; ray_br.y = ray.y + 8 * delta_y;
		vec3 ray_bl; ray_bl.x = ray.x; ray_bl.y = ray.y + 8 * delta_y;
		
		float depth_tr = 0.0f;
		float depth_tl = 0.0f;
		float depth_br = 0.0f;
		float depth_bl = 0.0f;
		
		uint32 u_tr; uint32 v_tr;
		uint32 u_tl; uint32 v_tl;
		uint32 u_br; uint32 v_br;
		uint32 u_bl; uint32 v_bl;
		
		rayCalc(&ray_tr, &depth_tr, &u_tr, &v_tr);
		rayCalc(&ray_tl, &depth_tl, &u_tl, &v_tl);
		rayCalc(&ray_br, &depth_br, &u_br, &v_br);
		rayCalc(&ray_bl, &depth_bl, &u_bl, &v_bl);
		
		float luminance_tr = (light_factor - abs(depth_tr)) / light_factor;
		if (luminance_tr <= 0) {
			luminance_tr = 0.0f;
		}
		float luminance_tl = (light_factor - abs(depth_tl)) / light_factor;
		if (luminance_tl <= 0) {
			luminance_tl = 0.0f;
		}
		float luminance_br = (light_factor - abs(depth_br)) / light_factor;
		if (luminance_br <= 0) {
			luminance_br = 0.0f;
		}
		float luminance_bl = (light_factor - abs(depth_bl)) / light_factor;
		if (luminance_bl <= 0) {
			luminance_bl = 0.0f;
		}
		
		uint32 left_du = (u_bl - u_tl) / 8
		uint32 left_dv = (v_bl - v_tl) / 8
		uint32 right_du = (u_br - u_tr) / 8
		uint32 right_dv = (v_br - v_tr) / 8
		uint32 left_u = u_tl;
		uint32 left_v = v_tl;
		uint32 right_u = u_tr;
		uint32 right_v = v_tr;
		
		uint32 left_dlum = (luminance_bl - luminance_tl) / 8;
		uint32 right_dlum = (luminance_br - luminance_tr) / 8;
		uint32 left_lum = luminance_tl;
		uint32 right_lum = luminance_tr;
		
		uint32 du = 0, dv = 0;
		uint32 u = 0, v = 0;
		uint32 dlum = 0;
		uint32 lum = 0;
		
		for (int dy = 0; dy < 8; dy++) {
			du = (right_u - left_u) / 8;
			dv = (right_v - left_v) / 8;
			u = left_u;
			v = left_v;
			
			dlum = (right_lum - left_lum) / 8;
			lum = left_lum;
  
			for (int dx = 0; dx < 8; dx++) {
				// read texture
				uint32 pixel = getPixel(u, v);
				pixel *= lum;
				
				putPixel(pixel, x + dx, y + dy);
				
				u += du;
				v += dv;
				
				lum += dlum;
				
				ray.x += delta_x;
				ray.y += delta_y;
				ray.z += delta_z;
			}
			
			left_u += left_du;
			left_v += left_dv;
			right_u += right_du;
			right_v += right_dv;
			
			left_lum += left_dlum;
			right_lum += right_dlum;
		}
	}
}



unsigned char color_r = (0x000000ff & color);
          color_r  *= luminance;
          unsigned char color_g = (0x0000ff00 & color) >> 8;
          color_g *= luminance;
          unsigned char color_b = (0x00ff0000 & color) >> 16;
          color_b *= luminance;
          unsigned char color_a = (0xff000000 & color) >> 24;        

          color = (0xff000000 & (color_a << 24)) | 
                  (0x00ff0000 & (color_b << 16)) |
                  (0x0000ff00 & (color_g << 8))  |
                  (0x000000ff & (color_r));
